// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as $internal from "./internal.js";

/**
 * ClientVersion is information about the latest client version that's available
 * for the client (and whether they're already running it).
 * 
 * It does not include a URL to download the client, as that varies by platform.
 */
export class ClientVersion {
    /**
     * RunningLatest is true if the client is running the latest build.
     */
    "RunningLatest"?: boolean;

    /**
     * LatestVersion is the latest version.Short ("1.34.2") version available
     * for download for the client's platform and packaging type.
     * It won't be populated if RunningLatest is true.
     */
    "LatestVersion"?: string;

    /**
     * UrgentSecurityUpdate is set when the client is missing an important
     * security update. That update may be in LatestVersion or earlier.
     * UrgentSecurityUpdate should not be set if RunningLatest is false.
     */
    "UrgentSecurityUpdate"?: boolean;

    /**
     * Notify is whether the client should do an OS-specific notification about
     * a new version being available. This should not be populated if
     * RunningLatest is true. The client should not notify multiple times for
     * the same LatestVersion value.
     */
    "Notify"?: boolean;

    /**
     * NotifyURL is a URL to open in the browser when the user clicks on the
     * notification, when Notify is true.
     */
    "NotifyURL"?: string;

    /**
     * NotifyText is the text to show in the notification, when Notify is true.
     */
    "NotifyText"?: string;

    /** Creates a new ClientVersion instance. */
    constructor($$source: Partial<ClientVersion> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ClientVersion instance from a string or object.
     */
    static createFrom($$source: any = {}): ClientVersion {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ClientVersion($$parsedSource as Partial<ClientVersion>);
    }
}

/**
 * ID is an integer ID for a user, node, or login allocated by the
 * control plane.
 * 
 * To be nice, control plane servers should not use int64s that are too large to
 * fit in a JavaScript number (see JavaScript's Number.MAX_SAFE_INTEGER).
 * The Tailscale-hosted control plane stopped allocating large integers in
 * March 2023 but nodes prior to that may have IDs larger than
 * MAX_SAFE_INTEGER (2^53 – 1).
 * 
 * IDs must not be zero or negative.
 */
export type ID = number;

/**
 * Location represents geographical location data about a
 * Tailscale host. Location is optional and only set if
 * explicitly declared by a node.
 */
export class Location {
    /**
     * User friendly country name, with proper capitalization ("Canada")
     */
    "Country"?: string;

    /**
     * ISO 3166-1 alpha-2 in upper case ("CA")
     */
    "CountryCode"?: string;

    /**
     * User friendly city name, with proper capitalization ("Squamish")
     */
    "City"?: string;

    /**
     * CityCode is a short code representing the city in upper case.
     * CityCode is used to disambiguate a city from another location
     * with the same city name. It uniquely identifies a particular
     * geographical location, within the tailnet.
     * IATA, ICAO or ISO 3166-2 codes are recommended ("YSE")
     */
    "CityCode"?: string;

    /**
     * Latitude, Longitude are optional geographical coordinates of the node, in degrees.
     * No particular accuracy level is promised; the coordinates may simply be the center of the city or country.
     */
    "Latitude"?: number;
    "Longitude"?: number;

    /**
     * Priority determines the order of use of an exit node when a
     * location based preference matches more than one exit node,
     * the node with the highest priority wins. Nodes of equal
     * probability may be selected arbitrarily.
     * 
     * A value of 0 means the exit node does not have a priority
     * preference. A negative int is not allowed.
     */
    "Priority"?: number;

    /** Creates a new Location instance. */
    constructor($$source: Partial<Location> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Location instance from a string or object.
     */
    static createFrom($$source: any = {}): Location {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Location($$parsedSource as Partial<Location>);
    }
}

/**
 * NodeCapMap is a map of capabilities to their optional values. It is valid for
 * a capability to have no values (nil slice); such capabilities can be tested
 * for by using the [NodeCapMap.Contains] method.
 * 
 * See [NodeCapability] for more information on keys.
 */
export type NodeCapMap = { [_: string]: RawMessage[] };

/**
 * NodeCapability represents a capability granted to the self node as listed in
 * MapResponse.Node.Capabilities.
 * 
 * It must be a URL like "https://tailscale.com/cap/file-sharing", or a
 * well-known capability name like "funnel". The latter is only allowed for
 * Tailscale-defined capabilities.
 * 
 * Unlike PeerCapability, NodeCapability is not in context of a peer and is
 * granted to the node itself.
 * 
 * These are also referred to as "Node Attributes" in the ACL policy file.
 */
export enum NodeCapability {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    CapabilityFileSharing = "https://tailscale.com/cap/file-sharing",
    CapabilityAdmin = "https://tailscale.com/cap/is-admin",

    /**
     * feature enabled/available
     */
    CapabilitySSH = "https://tailscale.com/cap/ssh",

    /**
     * some SSH rule reach this node
     */
    CapabilitySSHRuleIn = "https://tailscale.com/cap/ssh-rule-in",

    /**
     * feature enabled
     */
    CapabilityDataPlaneAuditLogs = "https://tailscale.com/cap/data-plane-audit-logs",

    /**
     * exposes debug endpoints over the PeerAPI
     */
    CapabilityDebug = "https://tailscale.com/cap/debug",
    CapabilityHTTPS = "https",

    /**
     * CapabilityBindToInterfaceByRoute changes how Darwin nodes create
     * sockets (in the net/netns package). See that package for more
     * details on the behaviour of this capability.
     */
    CapabilityBindToInterfaceByRoute = "https://tailscale.com/cap/bind-to-interface-by-route",

    /**
     * CapabilityDebugDisableAlternateDefaultRouteInterface changes how Darwin
     * nodes get the default interface. There is an optional hook (used by the
     * macOS and iOS clients) to override the default interface, this capability
     * disables that and uses the default behavior (of parsing the routing
     * table).
     */
    CapabilityDebugDisableAlternateDefaultRouteInterface = "https://tailscale.com/cap/debug-disable-alternate-default-route-interface",

    /**
     * CapabilityDebugDisableBindConnToInterface disables the automatic binding
     * of connections to the default network interface on Darwin nodes.
     */
    CapabilityDebugDisableBindConnToInterface = "https://tailscale.com/cap/debug-disable-bind-conn-to-interface",

    /**
     * CapabilityTailnetLock indicates the node may initialize tailnet lock.
     */
    CapabilityTailnetLock = "https://tailscale.com/cap/tailnet-lock",

    /**
     * CapabilityWarnFunnelNoInvite indicates whether Funnel is enabled for the tailnet.
     * This cap is no longer used 2023-08-09 onwards.
     */
    CapabilityWarnFunnelNoInvite = "https://tailscale.com/cap/warn-funnel-no-invite",

    /**
     * CapabilityWarnFunnelNoHTTPS indicates HTTPS has not been enabled for the tailnet.
     * This cap is no longer used 2023-08-09 onwards.
     */
    CapabilityWarnFunnelNoHTTPS = "https://tailscale.com/cap/warn-funnel-no-https",

    /**
     * CapabilityDebugTSDNSResolution enables verbose debug logging for DNS
     * resolution for Tailscale-controlled domains (the control server, log
     * server, DERP servers, etc.)
     */
    CapabilityDebugTSDNSResolution = "https://tailscale.com/cap/debug-ts-dns-resolution",

    /**
     * CapabilityFunnelPorts specifies the ports that the Funnel is available on.
     * The ports are specified as a comma-separated list of port numbers or port
     * ranges (e.g. "80,443,8080-8090") in the ports query parameter.
     * e.g. https://tailscale.com/cap/funnel-ports?ports=80,443,8080-8090
     */
    CapabilityFunnelPorts = "https://tailscale.com/cap/funnel-ports",

    /**
     * NodeAttrOnlyTCP443 specifies that the client should not attempt to generate
     * any outbound traffic that isn't TCP on port 443 (HTTPS). This is used for
     * clients in restricted environments where only HTTPS traffic is allowed
     * other types of traffic trips outbound firewall alarms. This thus implies
     * all traffic is over DERP.
     */
    NodeAttrOnlyTCP443 = "only-tcp-443",

    /**
     * NodeAttrFunnel grants the ability for a node to host ingress traffic.
     */
    NodeAttrFunnel = "funnel",

    /**
     * NodeAttrSSHAggregator grants the ability for a node to collect SSH sessions.
     */
    NodeAttrSSHAggregator = "ssh-aggregator",

    /**
     * NodeAttrDebugForceBackgroundSTUN forces a node to always do background
     * STUN queries regardless of inactivity.
     */
    NodeAttrDebugForceBackgroundSTUN = "debug-always-stun",

    /**
     * NodeAttrDebugDisableWGTrim disables the lazy WireGuard configuration,
     * always giving WireGuard the full netmap, even for idle peers.
     */
    NodeAttrDebugDisableWGTrim = "debug-no-wg-trim",

    /**
     * NodeAttrDisableSubnetsIfPAC controls whether subnet routers should be
     * disabled if WPAD is present on the network.
     */
    NodeAttrDisableSubnetsIfPAC = "debug-disable-subnets-if-pac",

    /**
     * NodeAttrDisableUPnP makes the client not perform a UPnP portmapping.
     * By default, we want to enable it to see if it works on more clients.
     * 
     * If UPnP catastrophically fails for people, this should be set kill
     * new attempts at UPnP connections.
     */
    NodeAttrDisableUPnP = "debug-disable-upnp",

    /**
     * NodeAttrDisableDeltaUpdates makes the client not process updates via the
     * delta update mechanism and should instead treat all netmap changes as
     * "full" ones as tailscaled did in 1.48.x and earlier.
     */
    NodeAttrDisableDeltaUpdates = "disable-delta-updates",

    /**
     * NodeAttrRandomizeClientPort makes magicsock UDP bind to
     * :0 to get a random local port, ignoring any configured
     * fixed port.
     */
    NodeAttrRandomizeClientPort = "randomize-client-port",

    /**
     * NodeAttrSilentDisco makes the client suppress disco heartbeats to its
     * peers.
     */
    NodeAttrSilentDisco = "silent-disco",

    /**
     * NodeAttrOneCGNATEnable makes the client prefer one big CGNAT /10 route
     * rather than a /32 per peer. At most one of this or
     * NodeAttrOneCGNATDisable may be set; if neither are, it's automatic.
     */
    NodeAttrOneCGNATEnable = "one-cgnat?v\u003Dtrue",

    /**
     * NodeAttrOneCGNATDisable makes the client prefer a /32 route per peer
     * rather than one big /10 CGNAT route. At most one of this or
     * NodeAttrOneCGNATEnable may be set; if neither are, it's automatic.
     */
    NodeAttrOneCGNATDisable = "one-cgnat?v\u003Dfalse",

    /**
     * NodeAttrPeerMTUEnable makes the client do path MTU discovery to its
     * peers. If it isn't set, it defaults to the client default.
     */
    NodeAttrPeerMTUEnable = "peer-mtu-enable",

    /**
     * NodeAttrDNSForwarderDisableTCPRetries disables retrying truncated
     * DNS queries over TCP if the response is truncated.
     */
    NodeAttrDNSForwarderDisableTCPRetries = "dns-forwarder-disable-tcp-retries",

    /**
     * NodeAttrLinuxMustUseIPTables forces Linux clients to use iptables for
     * netfilter management.
     * This cannot be set simultaneously with NodeAttrLinuxMustUseNfTables.
     */
    NodeAttrLinuxMustUseIPTables = "linux-netfilter?v\u003Diptables",

    /**
     * NodeAttrLinuxMustUseNfTables forces Linux clients to use nftables for
     * netfilter management.
     * This cannot be set simultaneously with NodeAttrLinuxMustUseIPTables.
     */
    NodeAttrLinuxMustUseNfTables = "linux-netfilter?v\u003Dnftables",

    /**
     * NodeAttrSeamlessKeyRenewal makes clients enable beta functionality
     * of renewing node keys without breaking connections.
     */
    NodeAttrSeamlessKeyRenewal = "seamless-key-renewal",

    /**
     * NodeAttrProbeUDPLifetime makes the client probe UDP path lifetime at the
     * tail end of an active direct connection in magicsock.
     */
    NodeAttrProbeUDPLifetime = "probe-udp-lifetime",

    /**
     * NodeAttrsTaildriveShare enables sharing via Taildrive.
     */
    NodeAttrsTaildriveShare = "drive:share",

    /**
     * NodeAttrsTaildriveAccess enables accessing shares via Taildrive.
     */
    NodeAttrsTaildriveAccess = "drive:access",

    /**
     * NodeAttrSuggestExitNode is applied to each exit node which the control plane has determined
     * is a recommended exit node.
     */
    NodeAttrSuggestExitNode = "suggest-exit-node",

    /**
     * NodeAttrDisableWebClient disables using the web client.
     */
    NodeAttrDisableWebClient = "disable-web-client",

    /**
     * NodeAttrLogExitFlows enables exit node destinations in network flow logs.
     */
    NodeAttrLogExitFlows = "log-exit-flows",

    /**
     * NodeAttrAutoExitNode permits the automatic exit nodes feature.
     */
    NodeAttrAutoExitNode = "auto-exit-node",

    /**
     * NodeAttrStoreAppCRoutes configures the node to store app connector routes persistently.
     */
    NodeAttrStoreAppCRoutes = "store-appc-routes",

    /**
     * NodeAttrSuggestExitNodeUI allows the currently suggested exit node to appear in the client GUI.
     */
    NodeAttrSuggestExitNodeUI = "suggest-exit-node-ui",

    /**
     * NodeAttrUserDialUseRoutes makes UserDial use either the peer dialer or the system dialer,
     * depending on the destination address and the configured routes. When present, it also makes
     * the DNS forwarder use UserDial instead of SystemDial when dialing resolvers.
     */
    NodeAttrUserDialUseRoutes = "user-dial-routes",

    /**
     * NodeAttrSSHBehaviorV1 forces SSH to use the V1 behavior (no su, run SFTP in-process)
     * Added 2024-05-29 in Tailscale version 1.68.
     */
    NodeAttrSSHBehaviorV1 = "ssh-behavior-v1",

    /**
     * NodeAttrSSHBehaviorV2 forces SSH to use the V2 behavior (use su, run SFTP in child process).
     * This overrides NodeAttrSSHBehaviorV1 if set.
     * See forceV1Behavior in ssh/tailssh/incubator.go for distinction between
     * V1 and V2 behavior.
     * Added 2024-08-06 in Tailscale version 1.72.
     */
    NodeAttrSSHBehaviorV2 = "ssh-behavior-v2",

    /**
     * NodeAttrDisableSplitDNSWhenNoCustomResolvers indicates that the node's
     * DNS manager should not adopt a split DNS configuration even though the
     * Config of the resolver only contains routes that do not specify custom
     * resolver(s), hence all DNS queries can be safely sent to the upstream
     * DNS resolver and the node's DNS forwarder doesn't need to handle all
     * DNS traffic.
     * This is for now (2024-06-06) an iOS-specific battery life optimization,
     * and this node attribute allows us to disable the optimization remotely
     * if needed.
     */
    NodeAttrDisableSplitDNSWhenNoCustomResolvers = "disable-split-dns-when-no-custom-resolvers",

    /**
     * NodeAttrDisableLocalDNSOverrideViaNRPT indicates that the node's DNS manager should not
     * create a default (catch-all) Windows NRPT rule when "Override local DNS" is enabled.
     * Without this rule, Windows 8.1 and newer devices issue parallel DNS requests to DNS servers
     * associated with all network adapters, even when "Override local DNS" is enabled and/or
     * a Mullvad exit node is being used, resulting in DNS leaks.
     * We began creating this rule on 2024-06-14, and this node attribute
     * allows us to disable the new behavior remotely if needed.
     */
    NodeAttrDisableLocalDNSOverrideViaNRPT = "disable-local-dns-override-via-nrpt",

    /**
     * NodeAttrDisableMagicSockCryptoRouting disables the use of the
     * magicsock cryptorouting hook. See tailscale/corp#20732.
     */
    NodeAttrDisableMagicSockCryptoRouting = "disable-magicsock-crypto-routing",

    /**
     * NodeAttrDisableCaptivePortalDetection instructs the client to not perform captive portal detection
     * automatically when the network state changes.
     */
    NodeAttrDisableCaptivePortalDetection = "disable-captive-portal-detection",

    /**
     * NodeAttrDisableSkipStatusQueue is set when the node should disable skipping
     * of queued netmap.NetworkMap between the controlclient and LocalBackend.
     * See tailscale/tailscale#14768.
     */
    NodeAttrDisableSkipStatusQueue = "disable-skip-status-queue",

    /**
     * NodeAttrSSHEnvironmentVariables enables logic for handling environment variables sent
     * via SendEnv in the SSH server and applying them to the SSH session.
     */
    NodeAttrSSHEnvironmentVariables = "ssh-env-vars",

    /**
     * NodeAttrServiceHost indicates the VIP Services for which the client is
     * approved to act as a service host, and which IP addresses are assigned
     * to those VIP Services. Any VIP Services that the client is not
     * advertising can be ignored.
     * Each value of this key in [NodeCapMap] is of type [ServiceIPMappings].
     * If multiple values of this key exist, they should be merged in sequence
     * (replace conflicting keys).
     */
    NodeAttrServiceHost = "service-host",
};

/**
 * RawMessage is a raw encoded JSON value. It implements Marshaler and
 * Unmarshaler and can be used to delay JSON decoding or precompute a JSON
 * encoding.
 * 
 * It is like json.RawMessage but is a string instead of a []byte to better
 * portray immutable data.
 */
export type RawMessage = any;

/**
 * StableNodeID is a string form of [NodeID].
 * 
 * Different control plane servers should ideally have different StableNodeID
 * suffixes for different sites or regions.
 * 
 * Being a string, it's safer to use in JavaScript without worrying about the
 * size of the integer, as documented on [NodeID].
 * 
 * But in general, Tailscale APIs can accept either a [NodeID] integer or a
 * [StableNodeID] string when referring to a node.
 */
export type StableNodeID = string;

/**
 * UserID is an [ID] for a [User].
 */
export type UserID = ID;

/**
 * A UserProfile is display-friendly data for a [User].
 * It includes the LoginName for display purposes but *not* the Provider.
 * It also includes derived data from one of the user's logins.
 */
export class UserProfile {
    "ID": UserID;

    /**
     * "alice@smith.com"; for display purposes only (provider is not listed)
     */
    "LoginName": string;

    /**
     * "Alice Smith"
     */
    "DisplayName": string;
    "ProfilePicURL": string;

    /**
     * Roles exists for legacy reasons, to keep old macOS clients
     * happy. It JSON marshals as [].
     */
    "Roles": $internal.emptyStructJSONSlice;

    /** Creates a new UserProfile instance. */
    constructor($$source: Partial<UserProfile> = {}) {
        if (!("ID" in $$source)) {
            this["ID"] = (0 as UserID);
        }
        if (!("LoginName" in $$source)) {
            this["LoginName"] = "";
        }
        if (!("DisplayName" in $$source)) {
            this["DisplayName"] = "";
        }
        if (!("ProfilePicURL" in $$source)) {
            this["ProfilePicURL"] = "";
        }
        if (!("Roles" in $$source)) {
            this["Roles"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new UserProfile instance from a string or object.
     */
    static createFrom($$source: any = {}): UserProfile {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new UserProfile($$parsedSource as Partial<UserProfile>);
    }
}
