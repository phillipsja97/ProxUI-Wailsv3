// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as netip$0 from "../../../net/netip/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as tailcfg$0 from "../../tailcfg/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as key$0 from "../../types/key/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as views$0 from "../../types/views/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../time/models.js";

/**
 * ExitNodeStatus describes the current exit node.
 */
export class ExitNodeStatus {
    /**
     * ID is the exit node's ID.
     */
    "ID": tailcfg$0.StableNodeID;

    /**
     * Online is whether the exit node is alive.
     */
    "Online": boolean;

    /**
     * TailscaleIPs are the exit node's IP addresses assigned to the node.
     */
    "TailscaleIPs": netip$0.Prefix[];

    /** Creates a new ExitNodeStatus instance. */
    constructor($$source: Partial<ExitNodeStatus> = {}) {
        if (!("ID" in $$source)) {
            this["ID"] = ("" as tailcfg$0.StableNodeID);
        }
        if (!("Online" in $$source)) {
            this["Online"] = false;
        }
        if (!("TailscaleIPs" in $$source)) {
            this["TailscaleIPs"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ExitNodeStatus instance from a string or object.
     */
    static createFrom($$source: any = {}): ExitNodeStatus {
        const $$createField2_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TailscaleIPs" in $$parsedSource) {
            $$parsedSource["TailscaleIPs"] = $$createField2_0($$parsedSource["TailscaleIPs"]);
        }
        return new ExitNodeStatus($$parsedSource as Partial<ExitNodeStatus>);
    }
}

/**
 * PeerStatus describes a peer node and its current state.
 */
export class PeerStatus {
    "ID": tailcfg$0.StableNodeID;
    "PublicKey": key$0.NodePublic;

    /**
     * HostInfo's Hostname (not a DNS name or necessarily unique)
     */
    "HostName": string;

    /**
     * DNSName is the Peer's FQDN. It ends with a dot.
     * It has the form "host.<MagicDNSSuffix>."
     */
    "DNSName": string;

    /**
     * HostInfo.OS
     */
    "OS": string;
    "UserID": tailcfg$0.UserID;

    /**
     * AltSharerUserID is the user who shared this node
     * if it's different than UserID. Otherwise it's zero.
     */
    "AltSharerUserID"?: tailcfg$0.UserID;

    /**
     * TailscaleIPs are the IP addresses assigned to the node.
     */
    "TailscaleIPs": netip$0.Addr[];

    /**
     * AllowedIPs are IP addresses allowed to route to this node.
     */
    "AllowedIPs"?: views$0.Slice<netip$0.Prefix> | null;

    /**
     * Tags are the list of ACL tags applied to this node.
     * See tailscale.com/tailcfg#Node.Tags for more information.
     */
    "Tags"?: views$0.Slice<string> | null;

    /**
     * PrimaryRoutes are the routes this node is currently the primary
     * subnet router for, as determined by the control plane. It does
     * not include the IPs in TailscaleIPs.
     */
    "PrimaryRoutes"?: views$0.Slice<netip$0.Prefix> | null;

    /**
     * Endpoints:
     */
    "Addrs": string[];

    /**
     * one of Addrs, or unique if roaming
     */
    "CurAddr": string;

    /**
     * DERP region
     */
    "Relay": string;
    "RxBytes": number;
    "TxBytes": number;

    /**
     * time registered with tailcontrol
     */
    "Created": time$0.Time;

    /**
     * time last packet sent
     */
    "LastWrite": time$0.Time;

    /**
     * last seen to tailcontrol; only present if offline
     */
    "LastSeen": time$0.Time;

    /**
     * with local wireguard
     */
    "LastHandshake": time$0.Time;

    /**
     * whether node is connected to the control plane
     */
    "Online": boolean;

    /**
     * true if this is the currently selected exit node.
     */
    "ExitNode": boolean;

    /**
     * true if this node can be an exit node (offered && approved)
     */
    "ExitNodeOption": boolean;

    /**
     * Active is whether the node was recently active. The
     * definition is somewhat undefined but has historically and
     * currently means that there was some packet sent to this
     * peer in the past two minutes. That definition is subject to
     * change.
     */
    "Active": boolean;

    /**
     * PeerAPIURL are the URLs of the node's PeerAPI servers.
     */
    "PeerAPIURL": string[];

    /**
     * Capabilities are capabilities that the node has.
     * They're free-form strings, but should be in the form of URLs/URIs
     * such as:
     *    "https://tailscale.com/cap/is-admin"
     *    "https://tailscale.com/cap/file-sharing"
     *    "funnel"
     * 
     * Deprecated: use CapMap instead. See https://github.com/tailscale/tailscale/issues/11508
     * Every value is Capabilities is also a key in CapMap, even if it
     * has no values in that map.
     */
    "Capabilities"?: tailcfg$0.NodeCapability[];

    /**
     * CapMap is a map of capabilities to their values.
     */
    "CapMap"?: tailcfg$0.NodeCapMap;

    /**
     * SSH_HostKeys are the node's SSH host keys, if known.
     */
    "sshHostKeys"?: string[];

    /**
     * ShareeNode indicates this node exists in the netmap because
     * it's owned by a shared-to user and that node might connect
     * to us. These nodes should be hidden by "tailscale status"
     * etc by default.
     */
    "ShareeNode"?: boolean;

    /**
     * InNetworkMap means that this peer was seen in our latest network map.
     * In theory, all of InNetworkMap and InMagicSock and InEngine should all be true.
     */
    "InNetworkMap": boolean;

    /**
     * InMagicSock means that this peer is being tracked by magicsock.
     * In theory, all of InNetworkMap and InMagicSock and InEngine should all be true.
     */
    "InMagicSock": boolean;

    /**
     * InEngine means that this peer is tracked by the wireguard engine.
     * In theory, all of InNetworkMap and InMagicSock and InEngine should all be true.
     */
    "InEngine": boolean;

    /**
     * Expired means that this peer's node key has expired, based on either
     * information from control or optimisically set on the client if the
     * expiration time has passed.
     */
    "Expired"?: boolean;

    /**
     * KeyExpiry, if present, is the time at which the node key expired or
     * will expire.
     */
    "KeyExpiry"?: time$0.Time | null;
    "Location"?: tailcfg$0.Location | null;

    /** Creates a new PeerStatus instance. */
    constructor($$source: Partial<PeerStatus> = {}) {
        if (!("ID" in $$source)) {
            this["ID"] = ("" as tailcfg$0.StableNodeID);
        }
        if (!("PublicKey" in $$source)) {
            this["PublicKey"] = "";
        }
        if (!("HostName" in $$source)) {
            this["HostName"] = "";
        }
        if (!("DNSName" in $$source)) {
            this["DNSName"] = "";
        }
        if (!("OS" in $$source)) {
            this["OS"] = "";
        }
        if (!("UserID" in $$source)) {
            this["UserID"] = (0 as tailcfg$0.UserID);
        }
        if (!("TailscaleIPs" in $$source)) {
            this["TailscaleIPs"] = [];
        }
        if (!("Addrs" in $$source)) {
            this["Addrs"] = [];
        }
        if (!("CurAddr" in $$source)) {
            this["CurAddr"] = "";
        }
        if (!("Relay" in $$source)) {
            this["Relay"] = "";
        }
        if (!("RxBytes" in $$source)) {
            this["RxBytes"] = 0;
        }
        if (!("TxBytes" in $$source)) {
            this["TxBytes"] = 0;
        }
        if (!("Created" in $$source)) {
            this["Created"] = null;
        }
        if (!("LastWrite" in $$source)) {
            this["LastWrite"] = null;
        }
        if (!("LastSeen" in $$source)) {
            this["LastSeen"] = null;
        }
        if (!("LastHandshake" in $$source)) {
            this["LastHandshake"] = null;
        }
        if (!("Online" in $$source)) {
            this["Online"] = false;
        }
        if (!("ExitNode" in $$source)) {
            this["ExitNode"] = false;
        }
        if (!("ExitNodeOption" in $$source)) {
            this["ExitNodeOption"] = false;
        }
        if (!("Active" in $$source)) {
            this["Active"] = false;
        }
        if (!("PeerAPIURL" in $$source)) {
            this["PeerAPIURL"] = [];
        }
        if (!("InNetworkMap" in $$source)) {
            this["InNetworkMap"] = false;
        }
        if (!("InMagicSock" in $$source)) {
            this["InMagicSock"] = false;
        }
        if (!("InEngine" in $$source)) {
            this["InEngine"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new PeerStatus instance from a string or object.
     */
    static createFrom($$source: any = {}): PeerStatus {
        const $$createField7_0 = $$createType1;
        const $$createField11_0 = $$createType2;
        const $$createField24_0 = $$createType2;
        const $$createField25_0 = $$createType3;
        const $$createField26_0 = $$createType4;
        const $$createField27_0 = $$createType2;
        const $$createField34_0 = $$createType8;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TailscaleIPs" in $$parsedSource) {
            $$parsedSource["TailscaleIPs"] = $$createField7_0($$parsedSource["TailscaleIPs"]);
        }
        if ("Addrs" in $$parsedSource) {
            $$parsedSource["Addrs"] = $$createField11_0($$parsedSource["Addrs"]);
        }
        if ("PeerAPIURL" in $$parsedSource) {
            $$parsedSource["PeerAPIURL"] = $$createField24_0($$parsedSource["PeerAPIURL"]);
        }
        if ("Capabilities" in $$parsedSource) {
            $$parsedSource["Capabilities"] = $$createField25_0($$parsedSource["Capabilities"]);
        }
        if ("CapMap" in $$parsedSource) {
            $$parsedSource["CapMap"] = $$createField26_0($$parsedSource["CapMap"]);
        }
        if ("sshHostKeys" in $$parsedSource) {
            $$parsedSource["sshHostKeys"] = $$createField27_0($$parsedSource["sshHostKeys"]);
        }
        if ("Location" in $$parsedSource) {
            $$parsedSource["Location"] = $$createField34_0($$parsedSource["Location"]);
        }
        return new PeerStatus($$parsedSource as Partial<PeerStatus>);
    }
}

/**
 * Status represents the entire state of the IPN network.
 */
export class Status {
    /**
     * Version is the daemon's long version (see version.Long).
     */
    "Version": string;

    /**
     * TUN is whether /dev/net/tun (or equivalent kernel interface) is being
     * used. If false, it's running in userspace mode.
     */
    "TUN": boolean;

    /**
     * BackendState is an ipn.State string value:
     *  "NoState", "NeedsLogin", "NeedsMachineAuth", "Stopped",
     *  "Starting", "Running".
     */
    "BackendState": string;

    /**
     * HaveNodeKey is whether the current profile has a node key configured.
     */
    "HaveNodeKey"?: boolean;

    /**
     * current URL provided by control to authorize client
     */
    "AuthURL": string;

    /**
     * Tailscale IP(s) assigned to this node
     */
    "TailscaleIPs": netip$0.Addr[];
    "Self": PeerStatus | null;

    /**
     * ExitNodeStatus describes the current exit node.
     * If nil, an exit node is not in use.
     */
    "ExitNodeStatus"?: ExitNodeStatus | null;

    /**
     * Health contains health check problems.
     * Empty means everything is good. (or at least that no known
     * problems are detected)
     */
    "Health": string[];

    /**
     * This field is the legacy name of CurrentTailnet.MagicDNSSuffix.
     * 
     * Deprecated: use CurrentTailnet.MagicDNSSuffix instead.
     */
    "MagicDNSSuffix": string;

    /**
     * CurrentTailnet is information about the tailnet that the node
     * is currently connected to. When not connected, this field is nil.
     */
    "CurrentTailnet": TailnetStatus | null;

    /**
     * CertDomains are the set of DNS names for which the control
     * plane server will assist with provisioning TLS
     * certificates. See SetDNSRequest for dns-01 ACME challenges
     * for e.g. LetsEncrypt. These names are FQDNs without
     * trailing periods, and without any "_acme-challenge." prefix.
     */
    "CertDomains": string[];

    /**
     * Peer is the state of each peer, keyed by each peer's current public key.
     */
    "Peer": { [_: string]: PeerStatus | null };

    /**
     * User contains profile information about UserIDs referenced by
     * PeerStatus.UserID, PeerStatus.AltSharerUserID, etc.
     */
    "User": { [_: string]: tailcfg$0.UserProfile };

    /**
     * ClientVersion, when non-nil, contains information about the latest
     * version of the Tailscale client that's available. Depending on
     * the platform and client settings, it may not be available.
     */
    "ClientVersion": tailcfg$0.ClientVersion | null;

    /** Creates a new Status instance. */
    constructor($$source: Partial<Status> = {}) {
        if (!("Version" in $$source)) {
            this["Version"] = "";
        }
        if (!("TUN" in $$source)) {
            this["TUN"] = false;
        }
        if (!("BackendState" in $$source)) {
            this["BackendState"] = "";
        }
        if (!("AuthURL" in $$source)) {
            this["AuthURL"] = "";
        }
        if (!("TailscaleIPs" in $$source)) {
            this["TailscaleIPs"] = [];
        }
        if (!("Self" in $$source)) {
            this["Self"] = null;
        }
        if (!("Health" in $$source)) {
            this["Health"] = [];
        }
        if (!("MagicDNSSuffix" in $$source)) {
            this["MagicDNSSuffix"] = "";
        }
        if (!("CurrentTailnet" in $$source)) {
            this["CurrentTailnet"] = null;
        }
        if (!("CertDomains" in $$source)) {
            this["CertDomains"] = [];
        }
        if (!("Peer" in $$source)) {
            this["Peer"] = {};
        }
        if (!("User" in $$source)) {
            this["User"] = {};
        }
        if (!("ClientVersion" in $$source)) {
            this["ClientVersion"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Status instance from a string or object.
     */
    static createFrom($$source: any = {}): Status {
        const $$createField5_0 = $$createType1;
        const $$createField6_0 = $$createType10;
        const $$createField7_0 = $$createType12;
        const $$createField8_0 = $$createType2;
        const $$createField10_0 = $$createType14;
        const $$createField11_0 = $$createType2;
        const $$createField12_0 = $$createType15;
        const $$createField13_0 = $$createType17;
        const $$createField14_0 = $$createType19;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("TailscaleIPs" in $$parsedSource) {
            $$parsedSource["TailscaleIPs"] = $$createField5_0($$parsedSource["TailscaleIPs"]);
        }
        if ("Self" in $$parsedSource) {
            $$parsedSource["Self"] = $$createField6_0($$parsedSource["Self"]);
        }
        if ("ExitNodeStatus" in $$parsedSource) {
            $$parsedSource["ExitNodeStatus"] = $$createField7_0($$parsedSource["ExitNodeStatus"]);
        }
        if ("Health" in $$parsedSource) {
            $$parsedSource["Health"] = $$createField8_0($$parsedSource["Health"]);
        }
        if ("CurrentTailnet" in $$parsedSource) {
            $$parsedSource["CurrentTailnet"] = $$createField10_0($$parsedSource["CurrentTailnet"]);
        }
        if ("CertDomains" in $$parsedSource) {
            $$parsedSource["CertDomains"] = $$createField11_0($$parsedSource["CertDomains"]);
        }
        if ("Peer" in $$parsedSource) {
            $$parsedSource["Peer"] = $$createField12_0($$parsedSource["Peer"]);
        }
        if ("User" in $$parsedSource) {
            $$parsedSource["User"] = $$createField13_0($$parsedSource["User"]);
        }
        if ("ClientVersion" in $$parsedSource) {
            $$parsedSource["ClientVersion"] = $$createField14_0($$parsedSource["ClientVersion"]);
        }
        return new Status($$parsedSource as Partial<Status>);
    }
}

/**
 * TailnetStatus is information about a Tailscale network ("tailnet").
 */
export class TailnetStatus {
    /**
     * Name is the name of the network that's currently in use.
     */
    "Name": string;

    /**
     * MagicDNSSuffix is the network's MagicDNS suffix for nodes
     * in the network such as "userfoo.tailscale.net".
     * There are no surrounding dots.
     * MagicDNSSuffix should be populated regardless of whether a domain
     * has MagicDNS enabled.
     */
    "MagicDNSSuffix": string;

    /**
     * MagicDNSEnabled is whether or not the network has MagicDNS enabled.
     * Note that the current device may still not support MagicDNS if
     * `--accept-dns=false` was used.
     */
    "MagicDNSEnabled": boolean;

    /** Creates a new TailnetStatus instance. */
    constructor($$source: Partial<TailnetStatus> = {}) {
        if (!("Name" in $$source)) {
            this["Name"] = "";
        }
        if (!("MagicDNSSuffix" in $$source)) {
            this["MagicDNSSuffix"] = "";
        }
        if (!("MagicDNSEnabled" in $$source)) {
            this["MagicDNSEnabled"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TailnetStatus instance from a string or object.
     */
    static createFrom($$source: any = {}): TailnetStatus {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TailnetStatus($$parsedSource as Partial<TailnetStatus>);
    }
}

// Private type creation functions
const $$createType0 = $Create.Array($Create.Any);
const $$createType1 = $Create.Array($Create.Any);
const $$createType2 = $Create.Array($Create.Any);
const $$createType3 = $Create.Array($Create.Any);
var $$createType4 = (function $$initCreateType4(...args): any {
    if ($$createType4 === $$initCreateType4) {
        $$createType4 = $$createType6;
    }
    return $$createType4(...args);
});
const $$createType5 = $Create.Array($Create.Any);
const $$createType6 = $Create.Map($Create.Any, $$createType5);
const $$createType7 = tailcfg$0.Location.createFrom;
const $$createType8 = $Create.Nullable($$createType7);
const $$createType9 = PeerStatus.createFrom;
const $$createType10 = $Create.Nullable($$createType9);
const $$createType11 = ExitNodeStatus.createFrom;
const $$createType12 = $Create.Nullable($$createType11);
const $$createType13 = TailnetStatus.createFrom;
const $$createType14 = $Create.Nullable($$createType13);
const $$createType15 = $Create.Map($Create.Any, $$createType10);
const $$createType16 = tailcfg$0.UserProfile.createFrom;
const $$createType17 = $Create.Map($Create.Any, $$createType16);
const $$createType18 = tailcfg$0.ClientVersion.createFrom;
const $$createType19 = $Create.Nullable($$createType18);
